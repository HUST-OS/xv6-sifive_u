*author:Sukuna*

### 内核实现--时钟中断

RISC-V的CPU在一定的时间段就会触发一次时钟中断,RISC-V希望时钟中断能在M态处理而不是在S态处理.我们选择在一个特殊的方法来处理时钟中断.

在`start.c`中,我们设置了把所有中断都放在S态进行处理.但是我们在`timerinit`函数中创建了一个专属于时钟中断的处理模式,在这个函数中,我们主要是获得了时钟中断的锁.

当时钟中断产生的时候,我们一般认为这个中断是一个设备中断:在`devintr`函数中我们看到了时钟中断的处理逻辑:

```C
	else if (0x8000000000000005L == scause) {
		timer_tick();
		return 2;
	}
```

每一次时钟中断都会调用`timer_tick`函数:

- 通知因为sleep导致睡眠的进程.
- 设置下一次时钟中断的时间.

```C
void timer_tick() {
    acquire(&tickslock);
    ticks++;
    wakeup(&ticks);
    release(&tickslock);
    set_next_timeout();
}
```

在`set_next_timeout`函数中,我们通过sbi接口设置了下一次时钟中断的时间:

```C
void
set_next_timeout() {
    // There is a very strange bug,
    // if comment the `printf` line below
    // the timer will not work.

    // this bug seems to disappear automatically
    // printf("");
    sbi_set_timer(r_time() + INTERVAL);
}
```

